<script>
function isNeighbor(point1, point2) {
  return Math.abs(point1[0] - point2[0]) + Math.abs(point1[1] - point2[1]) === 1;
}

function isEqual(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}

/** 是否直线（至少 5 个在一条线上） */
function isStraight(points) {
  const map = {};
  for (const [x, y] of points) {
    const keyX = `x${x}`;
    const keyY = `y${y}`;
    if (!map[keyX]) {
      map[keyX] = 0;
    }
    map[keyX] += 1;
    if (!map[keyY]) {
      map[keyY] = 0;
    }
    map[keyY] += 1;
  }
  return Object.values(map).some((v) => v >= 5);
}

function getIndexOf(points, point) {
  for (let i = 0; i < points.length; i++) {
    const p = points[i];
    if (isEqual(p, point)) {
      return i;
    }
  }
  return -1;
}

function getNeighborOf(point, points) {
  for (const p of points) {
    if (isNeighbor(p, point)) {
      return p;
    }
  }
}

/**
 * 获取路径
 * @param from 起点
 * @param to 重点
 * @param stops 可能的中途点
 */
function getSteps(from, to, stops) {
  // 如果是邻居，直接返回
  if (isNeighbor(from, to)) {
    return [to];
  }
  const steps = [];
  const clonedStops = stops.slice(0);
  let current = from;
  let stop;
  while ((stop = getNeighborOf(current, clonedStops))) {
    steps.push(stop);
    const index = clonedStops.indexOf(stop);
    clonedStops.splice(index, 1);
    current = stop;
    if (isNeighbor(current, to)) {
      steps.push(to);
      return steps;
    }
  }
  // 没找到，换个方向
  return getSteps(
    from,
    to,
    stops.filter((p) => {
      return steps.length === 0 || !isEqual(p, steps[steps.length - 1]);
    }),
  );
}

// [
//   [4] [ ] [ ] [ ] [ ]
//   [3] [ ] [ ] [ ] [ ]
//   [2] [ ] [6] [ ] [ ]
//   [1] [5] [Z] [7] [8]
//   [A] [ ] [ ] [ ] [ ]
// ]

const from = [0, 4];
const to = [2, 3];
const stops = [[0,3],[0,2],[0,1],[0,0],[1,3],[2,2],[3,3],[4,3]];

function test() {
  console.log(getSteps(from, to, stops));
}
</script>
